pub fn make_contiguous_strides(shape: &[i64]) -> Vec<i64> {
    let rank = shape.len();
    let mut strides = vec![1; rank];
    for i in (0..rank - 1).rev() {
        strides[i] = strides[i + 1] * shape[i + 1];
    }
    strides
}

pub fn is_contiguous(shape: &[i64], strides: &[i64]) -> bool {
    assert_eq!(
        shape.len(),
        strides.len(),
        "shape and strides should have same length"
    );
    let mut expected = 1;
    for (&dim_size, &stride) in shape.iter().rev().zip(strides.iter().rev()) {
        if dim_size != 1 {
            if stride != expected {
                return false;
            }
            expected = expected
                .checked_mul(dim_size)
                .expect("overflow in stride calc");
        }
    }
    true
}

// Generated by copilot.
#[cfg(test)]
mod tests {
    use super::*;

    // test make_contiguous_strides
    #[test]
    fn test_make_contiguous_strides() {
        let shape = vec![1, 2, 3];
        let strides = make_contiguous_strides(&shape);
        assert_eq!(strides, vec![6, 3, 1]);
    }

    // test is_contiguous
    #[test]
    fn test_is_contiguous() {
        let shape = vec![1, 2, 3];
        let strides = vec![6, 3, 1];
        assert_eq!(is_contiguous(&shape, &strides), true);
    }
}
